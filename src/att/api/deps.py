"""Shared API dependency providers."""

from __future__ import annotations

import re
import subprocess
from pathlib import Path
from typing import Literal

from att.core.code_manager import CodeManager
from att.core.debug_manager import DebugManager
from att.core.deploy_manager import DeployManager
from att.core.git_manager import GitManager
from att.core.project_manager import ProjectManager
from att.core.runtime_manager import RuntimeManager
from att.core.self_bootstrap_integrations import parse_gh_actions_status
from att.core.self_bootstrap_manager import (
    ReleaseMetadata,
    ReleaseSourceContext,
    RestartWatchdogSignal,
    SelfBootstrapManager,
)
from att.core.test_runner import TestResultPayload, TestRunner
from att.core.tool_orchestrator import ToolOrchestrator
from att.db.store import SQLiteStore
from att.mcp.client import MCPClientManager, create_nat_mcp_transport_adapter

APP_DB_PATH = Path(".att/att.db")
_RUNTIME_MANAGER = RuntimeManager()
_CODE_MANAGER = CodeManager()
_GIT_MANAGER = GitManager()
_TEST_RUNNER = TestRunner()
_DEBUG_MANAGER = DebugManager()
_DEPLOY_MANAGER = DeployManager(_RUNTIME_MANAGER)
_MCP_CLIENT_MANAGER = MCPClientManager(
    transport_adapter=create_nat_mcp_transport_adapter(),
)
_TEST_RESULTS: dict[str, TestResultPayload] = {}
_DEBUG_LOGS: dict[str, list[str]] = {}
_RELEASE_LOG_FIELD_PATTERN = re.compile(
    r"\b(?P<key>release_id|previous_release_id)\s*[=:]\s*(?P<value>[A-Za-z0-9][A-Za-z0-9._:/-]*)"
)


def get_store() -> SQLiteStore:
    APP_DB_PATH.parent.mkdir(parents=True, exist_ok=True)
    return SQLiteStore(db_path=APP_DB_PATH)


def get_project_manager() -> ProjectManager:
    return ProjectManager(store=get_store())


def get_code_manager() -> CodeManager:
    return _CODE_MANAGER


def get_git_manager() -> GitManager:
    return _GIT_MANAGER


def get_runtime_manager() -> RuntimeManager:
    return _RUNTIME_MANAGER


def get_test_runner() -> TestRunner:
    return _TEST_RUNNER


def get_debug_manager() -> DebugManager:
    return _DEBUG_MANAGER


def get_deploy_manager() -> DeployManager:
    return _DEPLOY_MANAGER


def get_mcp_client_manager() -> MCPClientManager:
    return _MCP_CLIENT_MANAGER


def get_tool_orchestrator() -> ToolOrchestrator:
    return ToolOrchestrator(
        code_manager=get_code_manager(),
        git_manager=get_git_manager(),
        test_runner=get_test_runner(),
        store=get_store(),
    )


def get_self_bootstrap_manager() -> SelfBootstrapManager:
    store = get_store()
    git = get_git_manager()
    deploy = get_deploy_manager()
    runtime = get_runtime_manager()

    async def ci_checker(
        project_id: str,
        branch_name: str,
    ) -> Literal["pending", "success", "failure"]:
        project = await store.get_project(project_id)
        if project is None:
            return "failure"
        try:
            actions = git.actions(project.path)
        except RuntimeError:
            return "pending"
        return parse_gh_actions_status(actions.output, branch_name)

    async def pr_creator(project_id: str, branch_name: str) -> str:
        project = await store.get_project(project_id)
        if project is None:
            msg = f"Project not found: {project_id}"
            raise RuntimeError(msg)
        result = git.pr_create(
            project.path,
            title=f"ATT self-bootstrap: {branch_name}",
            body="Automated self-bootstrap update generated by ATT.",
            base="dev",
            head=branch_name,
        )
        return result.output

    async def pr_merger(project_id: str, pull_request: str) -> bool:
        project = await store.get_project(project_id)
        if project is None:
            return False
        try:
            git.pr_merge(project.path, pull_request=pull_request, strategy="squash")
        except RuntimeError:
            return False
        return True

    async def deployer(project_id: str, target: str) -> bool:
        del target
        project = await store.get_project(project_id)
        if project is None or project.nat_config_path is None:
            return False
        config_path = (
            project.nat_config_path
            if project.nat_config_path.is_absolute()
            else project.path / project.nat_config_path
        )
        status = deploy.run(project.path, config_path)
        return status.running

    async def restart_watchdog(project_id: str, target: str) -> RestartWatchdogSignal:
        del project_id
        probe_target = target if target.startswith(("http://", "https://")) else None
        probe = runtime.probe_health(url=probe_target)
        return RestartWatchdogSignal(
            stable=probe.healthy,
            reason=probe.reason,
            probe=probe.probe,
        )

    async def rollback_executor(project_id: str, target: str, release_id: str | None) -> bool:
        del project_id, target, release_id
        runtime.stop()
        return True

    async def runtime_release_metadata_adapter(
        context: ReleaseSourceContext,
    ) -> ReleaseMetadata | None:
        log_lines = runtime.logs(limit=200)
        current_release: str | None = None
        previous_release: str | None = None
        for line in reversed(log_lines):
            for match in _RELEASE_LOG_FIELD_PATTERN.finditer(line):
                key = match.group("key")
                value = match.group("value")
                if key == "release_id" and current_release is None:
                    current_release = value
                if key == "previous_release_id" and previous_release is None:
                    previous_release = value
            if current_release is not None and previous_release is not None:
                break
        if current_release is None:
            return None
        return ReleaseMetadata(
            current_release_id=current_release,
            previous_release_id=previous_release,
            source="runtime_logs",
        )

    async def git_release_metadata_adapter(
        context: ReleaseSourceContext,
    ) -> ReleaseMetadata | None:
        project_path = context.project_path

        def _git_rev_parse(revision: str) -> str | None:
            completed = subprocess.run(
                ["git", "rev-parse", revision],
                cwd=project_path,
                capture_output=True,
                text=True,
                check=False,
            )
            if completed.returncode != 0:
                return None
            value = completed.stdout.strip()
            return value or None

        current_release = _git_rev_parse("HEAD")
        if current_release is None:
            return None
        previous_release = _git_rev_parse("HEAD^")
        return ReleaseMetadata(
            current_release_id=current_release,
            previous_release_id=previous_release,
            source="git",
        )

    return SelfBootstrapManager(
        git_manager=git,
        orchestrator=get_tool_orchestrator(),
        store=store,
        ci_checker=ci_checker,
        pr_creator=pr_creator,
        pr_merger=pr_merger,
        deployer=deployer,
        restart_watchdog=restart_watchdog,
        rollback_executor=rollback_executor,
        release_source_adapters=(
            runtime_release_metadata_adapter,
            git_release_metadata_adapter,
        ),
    )


def get_test_result_store() -> dict[str, TestResultPayload]:
    return _TEST_RESULTS


def get_debug_log_store() -> dict[str, list[str]]:
    return _DEBUG_LOGS
