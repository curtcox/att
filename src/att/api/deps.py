"""Shared API dependency providers."""

from __future__ import annotations

from pathlib import Path
from typing import Literal

from att.core.code_manager import CodeManager
from att.core.debug_manager import DebugManager
from att.core.deploy_manager import DeployManager
from att.core.git_manager import GitManager
from att.core.project_manager import ProjectManager
from att.core.runtime_manager import RuntimeManager
from att.core.self_bootstrap_integrations import parse_gh_actions_status
from att.core.self_bootstrap_manager import SelfBootstrapManager
from att.core.test_runner import TestRunner
from att.core.tool_orchestrator import ToolOrchestrator
from att.db.store import SQLiteStore
from att.mcp.client import MCPClientManager

APP_DB_PATH = Path(".att/att.db")
_RUNTIME_MANAGER = RuntimeManager()
_CODE_MANAGER = CodeManager()
_GIT_MANAGER = GitManager()
_TEST_RUNNER = TestRunner()
_DEBUG_MANAGER = DebugManager()
_DEPLOY_MANAGER = DeployManager(_RUNTIME_MANAGER)
_MCP_CLIENT_MANAGER = MCPClientManager()
_TEST_RESULTS: dict[str, dict[str, str | int]] = {}
_DEBUG_LOGS: dict[str, list[str]] = {}


def get_store() -> SQLiteStore:
    APP_DB_PATH.parent.mkdir(parents=True, exist_ok=True)
    return SQLiteStore(db_path=APP_DB_PATH)


def get_project_manager() -> ProjectManager:
    return ProjectManager(store=get_store())


def get_code_manager() -> CodeManager:
    return _CODE_MANAGER


def get_git_manager() -> GitManager:
    return _GIT_MANAGER


def get_runtime_manager() -> RuntimeManager:
    return _RUNTIME_MANAGER


def get_test_runner() -> TestRunner:
    return _TEST_RUNNER


def get_debug_manager() -> DebugManager:
    return _DEBUG_MANAGER


def get_deploy_manager() -> DeployManager:
    return _DEPLOY_MANAGER


def get_mcp_client_manager() -> MCPClientManager:
    return _MCP_CLIENT_MANAGER


def get_tool_orchestrator() -> ToolOrchestrator:
    return ToolOrchestrator(
        code_manager=get_code_manager(),
        git_manager=get_git_manager(),
        test_runner=get_test_runner(),
        store=get_store(),
    )


def get_self_bootstrap_manager() -> SelfBootstrapManager:
    store = get_store()
    git = get_git_manager()

    async def ci_checker(
        project_id: str,
        branch_name: str,
    ) -> Literal["pending", "success", "failure"]:
        project = await store.get_project(project_id)
        if project is None:
            return "failure"
        try:
            actions = git.actions(project.path)
        except RuntimeError:
            return "pending"
        return parse_gh_actions_status(actions.output, branch_name)

    async def pr_creator(project_id: str, branch_name: str) -> str:
        project = await store.get_project(project_id)
        if project is None:
            msg = f"Project not found: {project_id}"
            raise RuntimeError(msg)
        result = git.pr_create(
            project.path,
            title=f"ATT self-bootstrap: {branch_name}",
            body="Automated self-bootstrap update generated by ATT.",
            base="dev",
            head=branch_name,
        )
        return result.output

    async def pr_merger(project_id: str, pull_request: str) -> bool:
        project = await store.get_project(project_id)
        if project is None:
            return False
        try:
            git.pr_merge(project.path, pull_request=pull_request, strategy="squash")
        except RuntimeError:
            return False
        return True

    return SelfBootstrapManager(
        git_manager=git,
        orchestrator=get_tool_orchestrator(),
        store=store,
        ci_checker=ci_checker,
        pr_creator=pr_creator,
        pr_merger=pr_merger,
    )


def get_test_result_store() -> dict[str, dict[str, str | int]]:
    return _TEST_RESULTS


def get_debug_log_store() -> dict[str, list[str]]:
    return _DEBUG_LOGS
